al items can always be found to the right, then new items can always be inserted at the bottom of the tree. In the tree above, for example, a node holding 8 would be placed to the right of (and “below”) the node holding 7. The decision process for a node is thus as follows:

Is the new item to insert less than our self.item? If so, the new item goes to the left:

Is self.left_n equal to None? If so, then we need to create a new node holding the new item, and set self.left_n to that node.
If not, we can pass the buck to self.left_n.


Otherwise, the item must be larger than or equal to self.item, so it needs to go to the right:

Is self.right_n equal to None? If so, then we need to create a new node holding the new item, and set self.right_n to that node.
If not, we can pass the buck to self.right_n.



In the previous figure of a tree, 8 would go to the right of 7, 6 would go to the left of 7, 18 would go the right of 11, and so on. The logic for inserting a new item is thus quite simple, from a node’s point of view:

The remaining method to consider is the tree’s .get_smallest(). In the case of a linked list, the smallest item (if present) was the first node in the list, and so could be accessed with no buck passing. But in the case of a binary tree, this isn’t true: the smallest item can be found all the way to the left. The code for .get_smallest() in the Tree class and the corresponding Node class reflects this.