afely be returned.
Otherwise:

If self.next_n is None, then False can be returned, because if the buck got passed to the end of the list, no node has matched the query.
If self.next_n does exist, on the other hand, just pass the buck down the line, and rely on the answer to come back, which can be returned.




Here is a quick demonstration of the usage (the whole script can be found in the file linkedlist.py):

Notice the similarity in all of these methods: each node first determines whether it can answer the problem—if so, it computes and returns the answer. If not, it checks for a node to pass the problem on to, and if one exists, the buck is passed. Notice that at each buck pass the method being called is the same—it’s just being called for a different object. And each time the overall “problem” gets smaller as the number of nodes left to pass the buck to decreases.
How much time does it take to insert an item into a list that is already of length? Because the new item might have to go at the end of the list, the buck might need to be passed times, meaning an insertion is . What about getting the smallest element? In the LinkedList’s .get_smallest() method, it only needs to determine whether self.first_n is None, and if not, it returns the element stored in that node. Because there is no buck passing, the time is .




Structure
Insert an Item
Get Smallest


Sorted Simple List




Sorted Linked List